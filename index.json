{
  "api/index.html": {
    "href": "api/index.html",
    "title": "Api Documentation | ValueStringBuilder",
    "keywords": "Api Documentation Here you will find an overview over all exposed objects and their documentation."
  },
  "articles/comparison.html": {
    "href": "articles/comparison.html",
    "title": "Comparison | ValueStringBuilder",
    "keywords": "Comparison The following document will show some key differences between the ValueStringBuilder and similar working string builder like the one from .NET itself. System.Text.StringBuilder The StringBuilder shipped with the .NET Framework itself is a all-purpose string builder which allows a versatile use. ValueStringBuilder tries to mimic the API as much as possible so developers can adopt the ValueStringBuilder easily where it makes sense. In the following part StringBuilder refers to System.Text.StringBuilder . Key differences : StringBuilder is a class and does not have the restrictions coming with a ref struct . To know more head over to the known limitations section. StringBuilder works not on Span<T> but more on string s or char s. Sometimes even with pointers StringBuilder uses chunks to represent the string, which the larger the string gets, the better it can perform. ValueStringBuilder only has one internal Span as representation which can cause fragmentation on very big strings. StringBuilder has a richer API as the ValueStringBuilder . In the future they should have the same amount of API's as the StringBuilder is the \"big brother\" of this package. ValueStringBuilder has different API calls like IndexOf or LastIndexOf . Benchmark The following table gives you a small comparison between the StringBuilder which is part of .NET and the ValueStringBuilder : BenchmarkDotNet v0.14.0, macOS Sequoia 15.3.1 (24D70) [Darwin 24.3.0] Apple M2 Pro, 1 CPU, 12 logical and 12 physical cores .NET SDK 9.0.200 [Host] : .NET 9.0.2 (9.0.225.6610), Arm64 RyuJIT AdvSIMD DefaultJob : .NET 9.0.2 (9.0.225.6610), Arm64 RyuJIT AdvSIMD | Method | Mean | Error | StdDev | Ratio | Gen0 | Allocated | Alloc Ratio | |-------------------- |----------:|---------:|---------:|------:|-------:|----------:|------------:| | DotNetStringBuilder | 126.74 ns | 0.714 ns | 0.667 ns | 1.00 | 0.1779 | 1488 B | 1.00 | | ValueStringBuilder | 95.69 ns | 0.118 ns | 0.110 ns | 0.76 | 0.0669 | 560 B | 0.38 | For more comparison check the documentation. Another benchmark shows that this ValueStringBuilder uses less memory when it comes to appending ValueTypes such as int , double , ... | Method | Mean | Error | StdDev | Gen0 | Gen1 | Allocated | |------------------------------- |---------:|--------:|--------:|-------:|-------:|----------:| | ValueStringBuilderAppendFormat | 821.7 ns | 1.29 ns | 1.14 ns | 0.4330 | - | 3.54 KB | | StringBuilderAppendFormat | 741.5 ns | 5.58 ns | 5.22 ns | 0.9909 | 0.0057 | 8.1 KB | Checkout the Benchmark for more detailed comparison and setup."
  },
  "articles/concepts.html": {
    "href": "articles/concepts.html",
    "title": "How does it work? | ValueStringBuilder",
    "keywords": "How does it work? Before I answer the question, I would like to raise another question: How does it work differently and more effectively than the current StringBuilder ? The basic idea is to use a ref struct which enforces that the ValueStringBuilder will live on the stack instead of the heap . Furthermore, we try to use advanced features like Span<T> and ArrayPool to reduce allocations even further. Because of the way C# / .NET is optimized for those types the ValueStringBuilder gains a lot of speed with low allocations. With this approach, some limitations arise. Head over to the known limitation to know more. Resources: Here is my detailed blog post about some of the implementation details."
  },
  "articles/getting_started.html": {
    "href": "articles/getting_started.html",
    "title": "Getting started | ValueStringBuilder",
    "keywords": "Getting started The following section will show you how to use the ValueStringBuilder . For .NET 6 use the nuget-package : PM> Install-Package LinkDotNet.StringBuilder Now that the package is installed the library can be used: using System; using LinkDotNet.StringBuilder; // Namespace of the library public static class Program { public static void Main() { var stringBuilder = new ValueStringBuilder(); stringBuilder.AppendLine(\"Hello World!\"); stringBuilder.Append(0.3f); stringBuilder.Insert(6, \"dear \"); Console.WriteLine(stringBuilder.ToString()); } } Prints: Here is an interactive example where you can fiddle around with the library. The example is hosted on https://dotnetfiddle.net/ and already has the ValueStringBuilder nuget package included in the latest version. Helper methods There are also very easy-to-use helper methods, which doesn't need a ValueStringBuilder instance: using LinkDotNet.StringBuilder; string helloWorld = ValueStringBuilder.Concat(\"Hello World!\", 101);"
  },
  "articles/known_limitations.html": {
    "href": "articles/known_limitations.html",
    "title": "Known Limitations | ValueStringBuilder",
    "keywords": "Known Limitations The base of the ValueStringBuilder is a ref struct . With that, there are certain limitations, which might make it not a good fit for your needs. ref struct s can only live on the stack and therefore can not be a field for a class or a non ref struct . Therefore they can't be boxed to ValueType or Object . Can't be captured by a lambda expression (aka closure). Can't be used in async methods. Can't be used in methods that use the yield keyword If not off this applies to your use case, you are good to go. Using ref struct is a trade for performance and fewer allocations in contrast to its use cases. ValueStringBuilder offers the possibility to \"convert\" it into a \"regular\" System.Text.StringBuilder . Check out the following extension method via the <xref:LinkDotNet.StringBuilder.ValueStringBuilderExtensions>. Fluent notation The normal StringBuilder offers a fluent way of appending new strings as follows: var stringBuilder = new StringBuilder(); var greeting = stringBuilder .AppendLine(\"Hello\") .AppendLine(\"World\") .Append(\"Not a new line afterwards\") .ToString(); This does not work with the ValueStringBuilder . The simple reason: struct s can't return ref this . If we don't return the reference then new allocations are introduced and can also lead to potential bugs/issues. Therefore it is a conscious design decision not to allow fluent notation. There are scenarios, where you can elide the using keyword. Exactly then when you provide the buffer in the first place and you are sure that no internal growing has to be done. This should only be done if you can guarantee that. // Reserve 128 bytes on the stack and don't use the using statement var stringBuilder = new ValueStringBuilder(stackalloc char[128]); stringBuilder.Append(\"Hello World\"); // Uses 11 bytes return stringBuilder.ToString();"
  },
  "articles/pass_to_method.html": {
    "href": "articles/pass_to_method.html",
    "title": "Passing the ValueStringBuilder to a method | ValueStringBuilder",
    "keywords": "Passing the ValueStringBuilder to a method As the ValueStringBuilder is ref struct you should be careful when passing the instance around. You should pass the reference and not the instance. public void MyFunction() { var stringBuilder = new ValueStringBuilder(); stringBuilder.Append(\"Hello \"); AppendMore(ref stringBuilder); } private void AppendMore(ref ValueStringBuilder builder) { builder.Append(\"World\"); } This will print: Hello World ⚠️ The following code snippet will show how it does not work. If the instance is passed not via reference but via value then first allocations will happen and second the end result is not what one would expect. public void MyFunction() { var stringBuilder = new ValueStringBuilder(); stringBuilder.Append(\"Hello \"); AppendMore(stringBuilder); } private void AppendMore(ValueStringBuilder builder) { builder.Append(\"World\"); } This will print: Hello ."
  },
  "index.html": {
    "href": "index.html",
    "title": "ValueStringBuilder: A fast and low allocation StringBuilder for .NET | ValueStringBuilder",
    "keywords": "ValueStringBuilder: A fast and low allocation StringBuilder for .NET ValueStringBuilder aims to be as fast as possible with a minimal amount of allocation memory. This documentation will showcase to you how to use the ValueStringBuilder as well as what are some limitations coming with it. If you have questions or feature requests just head over to the GitHub repository and file an issue. The library makes heavy use of Span<T> , stackalloc and ArrayPool s to achieve low allocations and fast performance. Download The package is hosted on nuget.org , so easily add the package reference: PM> Install-Package LinkDotNet.StringBuilder Afterwards, you can simply use it. It tries to mimic the API of the StringBuilder to a certain extent so for simpler cases you can exchange those two. Example usage The API is leaning towards the normal StringBuilder which is part of the .net framework itself. The main key difference is, that the ValueStringBuilder does not use the fluent notation of its \"big brother\". var stringBuilder = new ValueStringBuilder(); stringBuilder.AppendLine(\"Hello World\"); stringBuilder.Append(\"2+2=\"); stringBuilder.Append(4); Console.Write(stringBuilder.ToString()); This will print Hello World 2+2=4 There are also convenient helper methods like this: _ = ValueStringBuilder.Concat(\"Hello\", \" \", \"World\"); // \"Hello World\" _ = ValueStringBuilder.Concat(\"Hello\", 1, 2, 3, \"!\"); // \"Hello123!\""
  }
}